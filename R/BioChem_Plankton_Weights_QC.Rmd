---  
title: "BioChem plankton weight data:  \nQuality control checks"
output:
  pdf_document: 
    number_sections: true
    fig_caption: true
author: Benoit Casault
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
  \usepackage{float}
---

<!-- set options  -->
```{r, echo=FALSE}
knitr::opts_chunk$set(echo=FALSE, fig.pos='H')
# knitr::opts_knit$set(eval.after="fig.cap")
```

<!-------------------------------------------------------------------------------------------->
<!-- load libraries -->
```{r, echo=FALSE, eval=TRUE, include=FALSE}
library(knitr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(data.table)
library(kableExtra)
```

<!-- change directory so relative paths point to correct locations -->
```{r, echo=FALSE, eval=TRUE, include=FALSE}
wd <- getwd()
setwd("~/Projects/QualityControl_Biochem_weights/Rmd/")
```

<!-- load input data -->
```{r, echo=FALSE, eval=TRUE, include=FALSE}
# load sample_id and weights
input_file <- "~/Projects/QualityControl_Biochem_weights/outputs/PL_Weights.RData"
load(input_file)
```

<!-------------------------------------------------------------------------------------------->
# Scope
This report summarizes the results of quality control checks made on plankton weight data archived in BioChem.  It identifies plankton samples that have failed specific quality control tests and for which further assessment of data quality is required or recommended.

<!-------------------------------------------------------------------------------------------->
# Methodology
Quality control of BioChem plankton weight data was performed for ring net samples with a mesh size of 202 $\mu$m that have been labelled as adequate for standing stock calculations (*i.e.* meters_sqd_flag="Y").  The tests were done for all ring net data archived in BioChem without restriction to samples specific to AZMP.

A brief description of each quality control test is presented in the following sections. 
Checks were made at the following levels:

* Sample metadata (*i.e.* data from the BCPLANKTNHEDRS table)
* Sample weight data (*i.e.* data from the BCPLANKTNGENERALS table)
* Biomass data (*i.e.* sample weight data converted into biomass data)

The different codes used for data extraction and data processing can be provided upon request.

<!-------------------------------------------------------------------------------------------->
# Sample metadata checks
Sample metadata correspond to the data archived in the BCPLANKTNHEDRS table in BioChem which include relevant fields such as the start and end depth as well as the volume of water filtered for each net tow. Checks at the metadata level therefore consisted in verifying the coherence in the start and end depth of the net tow as well as the volume of water filtered during the tow.  A net tow should have an end_depth of zero (*i.e.* surface), a start_depth larger than the end_depth and a volume larger than zero.

## Negative start_depth and/or end_depth values
_Test description:_
The start_depth and end_depth of a net tow are typically entered as positive values.  This test checks for negative start_depth and/or end_depth values.

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check metadata - negative start_depth/end_depth
df_depth_negative <- df_sample %>%
	dplyr::select(., mission_descriptor, collector_sample_id, start_depth, end_depth) %>%
	dplyr::filter(., start_depth<0 | end_depth<0)

if(nrow(df_depth_negative)==0){
	cat("There were no samples identified showing negative start_depth and/or end_depth values.")
} else {
	knitr::kable(df_depth_negative,
							 caption="Samples with negative start\\_depth or end\\_depth values.",
							 format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_depth_negative)
```

_Action:_ No action required.

## Zero start_depth and end_depth values
_Test description:_
This test checks for net tows that have been assigned zero start_depth and end_depth values.

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check metadata - start_depth/end_depth
df_depth_zero <- df_sample %>%
	dplyr::select(., mission_descriptor, collector_sample_id, start_depth, end_depth) %>%
	dplyr::filter(., start_depth==0 & end_depth==0)

if(nrow(df_depth_zero)==0){
	cat("There were no samples identified showing zero start_depth and end_depth values.")
} else {
	knitr::kable(df_depth_zero,
							 caption="Samples with start\\_depth=end\\_depth=0.", format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_depth_zero)
```

_Action:_ Correction required such that start_depth is non-zero.

## Non-zero end_depth value.
_Test description:_
A net tow should end at the surface (*i.e.* end_depth=0) unless the start_depth and end_depth values have been inverted (see section 3.4).  This test checks for net tows not ending at the surface (*i.e.* end_depth>0).

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check metadata - Non-zero end_depth
df_depth_partial <- df_sample %>%
	dplyr::select(., mission_descriptor, collector_sample_id, start_depth, end_depth) %>%
	dplyr::filter(., abs(start_depth)>0 & abs(end_depth)>0)

if(nrow(df_depth_partial)==0){
	cat("There were no samples identified showing non-zero end_depth values.")
} else {
	knitr::kable(df_depth_partial,
							 caption="Samples with non-zero end\\_depth values.", format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_depth_partial)
```

_Action:_ Assess whether the non-zero end_depth values are acceptable.  These samples appear to be associated with the same event_id as samples where the tow ended at the surface (*i.e.* end_depth=0).

## start_depth/end_depth inversion
_Test description:_
A net tow should start at a given depth (*i.e.* start_depth>0) and end at the surface (*i.e.* end_depth=0).  This test checks for net tows where the start_depth and end_depth have been inverted.

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check metadata - start_depth/end_depth
df_depth_inversion <- df_sample %>%
	dplyr::select(., mission_descriptor, collector_sample_id, start_depth, end_depth) %>%
	dplyr::filter(., start_depth<end_depth)

if(nrow(df_depth_inversion)==0){
	cat("There were no samples identified showing net tow depth inversion.")
} else {
	knitr::kable(df_depth_inversion,
							 caption="Samples with start\\_depth < end\\_depth.", format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_depth_inversion)
```

_Action:_ Correction required such that start_depth>0 and end_depth=0.

## Zero or negative volume values
_Test description:_
This test checks for net tows that have been assigned negative or zero volume values.

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check metadata - volume
df_volume_zero <- df_sample %>%
	dplyr::select(., mission_descriptor, collector_sample_id, volume) %>%
	dplyr::filter(., volume<=0)

if(nrow(df_volume_zero)==0){
	cat("There were no samples identified showing zero or negative volume values.")
} else {
	knitr::kable(df_volume_zero,
							 caption="Samples with volume<=0.",format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position"))
}
rm(df_volume_zero)
```

_Action:_ Correction required such that volume>0.

<!-------------------------------------------------------------------------------------------->
# Sample weight data checks
Sample weight data correspond to the data archived in the BCPLANKTNGENERALS table in BioChem which include relevant fields such as the split fraction and the sieves used for analyzing each parameter (*i.e.* dry or wet weight) in a given sample.  Checks at the sample weight data level therefore consisted in verifying the coherence in the split fraction and sieves values for each sample.  The split fraction should take a value between 0 and 1. Each sample is filtered using one or two sieves; the min_sieve value should be finite and different from 0 (*e.g.* 0.202 mm).  The max_sieve value can be *NA* or finite (*e.g.* 10 mm) and larger than the min_sieve value.

## Negative or zero split_fraction values
_Test description:_
This test checks for erroneous split_fraction values (*i.e.* negative, zero or values larger than 1).

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check data - split fraction
df_split <- df_data %>%
	dplyr::filter(., split_fraction<=0 | split_fraction>1)

if(nrow(df_split)==0){
	cat("There were no samples identified showing negative, zero or larger than 1 split_fraction values.")
} else {
	knitr::kable(dplyr::left_join(df_split %>%
																	dplyr::select(., sample_id, split_fraction),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, split_fraction) %>%
							 	dplyr::distinct(.),
							 caption="Samples with negative or zero split\\_fraction values.",format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_split)
```

_Action:_ No action required.

## "NA"" or zero min_sieve values
_Test description:_
This test checks for erroneous min_sieve values (*i.e.* missing, negative or zero values).

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check data - min sieve
df_min_sieve <- df_data %>%
	dplyr::filter(., is.na(min_sieve) | min_sieve<=0)

if(nrow(df_min_sieve)==0){
	cat("There were no samples identified showing NA, negative or zero min_sieve values.")
} else {
	knitr::kable(dplyr::left_join(df_min_sieve %>%
																	dplyr::select(., sample_id, min_sieve, max_sieve),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, min_sieve, max_sieve) %>%
							 	dplyr::distinct(.),
							 caption="Samples with NA or zero min\\_sieve values.",format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_min_sieve)
```

_Action:_ Correction required such that min_sieve is non-zero.

## min_sieve value larger than max_sieve value
_Test description:_
This test checks for samples where the min_sieve value is larger than the max_sieve value.

_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check data - min/max sieve
df_sieve <- df_data %>%
	dplyr::filter(., !is.na(min_sieve) & !is.na(max_sieve) & min_sieve>=max_sieve)

if(nrow(df_sieve)==0){
	cat("There were no samples identified where min_sieve is larger than max_sieve values.")
} else {
	knitr::kable(dplyr::left_join(df_sieve %>%
																	dplyr::select(., sample_id, min_sieve, max_sieve),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, min_sieve, max_sieve) %>%
							 	dplyr::distinct(.),
							 caption="Samples with min\\_sieve >= max\\_sieve.",format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_sieve)
```

_Action:_ No action required.

## Non-standard min_sieve and max_sieve values
_Test description:_
This test checks for samples analyzed with non-standard min_sieve and max_sieve combinations (*i.e.* 0.202 & 10, 0.202 & NA, 10 & NA).

_Test result:_
<br>
There is a large number of samples (~200) where non-standard min_sieve and max_sieve combinations were used (*e.g.* 0.202 & 1, 0.202 & 2).  Due to the large number of samples, only the mission in which those samples were collected are listed here.

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# check data - min/max sieve
df_sieve_combo <- df_data %>%
	dplyr::filter(., !(((min_sieve==0.20 | min_sieve==0.202) & max_sieve==10) | ((min_sieve==0.20 | min_sieve==0.202) & is.na(max_sieve)) | (min_sieve==10 & is.na(max_sieve)))) %>%
	dplyr::filter(., min_sieve!=0) %>%
	dplyr::select(., sample_id, min_sieve, max_sieve)

if(nrow(df_sieve_combo)==0){
	cat("There were no samples identified where non-standard min_sieve and max_sieve combinations
			were used.")
} else {
	knitr::kable(dplyr::left_join(df_sieve_combo %>%
																	dplyr::select(., sample_id, min_sieve, max_sieve),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor) %>%
							 	dplyr::distinct(.),
							 caption="Missions where non-standard min\\_sieve and max\\_sieve combinations were used.",format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_sieve_combo)
```

_Action:_ Assessment is required to determine whether non-standard sieve values (*e.g.* 1, 2) associated with the above missions are acceptable.

<!-------------------------------------------------------------------------------------------->
# Biomass data checks
Biomass data (in units of $g/m^{2}$) are obtained from converting raw sample dry or wet weight data using the split fraction, start and end depths as well as the volume of filtered water for given net tow.  The min_sieve and max_sieve values are further used to differentiate between plankton size fractions.  Standard sieves combinations are as follows:

* min_sieve=0.202 and max_sieve=10 corresponds to mesoplankton (herein referred as small fraction)
* min_sieve=10 and max_sieve=NA corresponds to macroplankton (herein referred as large fraction)
* min_sieve=0.202 and max_sieve=NA corresponds to total plankton (but not including microplankton)

Checks at the biomass data level consisted in identifying extreme biomass values for the different size fractions for both the dry and wet biomass.  Extreme biomass values can be associated with data entry errors (*e.g.* erroneous units of measurement) or with the dominant presence of plankton individuals (whether extremely abundant or large, *e.g.* phytoplankton, salps) contributing to the bulk of the biomass in a given sample.  Checks were also made to verify the coherence in the contribution of each size fraction to the total wet or dry biomass (*i.e.* the sum of the small and large fraction should equal the total biomass) .  Checks were also made to verify the coherence in the comparison between dry and wet biomass for each size fraction (*i.e.* wet biomass should always be larger than the corresponding dry biomass).  Finally, checks were made to identify potential outliers in the overall relationship between the dry and wet biomass.

## Extreme biomass values
_Test description:_
This test looks at the distribution of the biomass data for each size fraction (*i.e.* small, large and total, herein referred to as S, L and T, respectively) and biomass category (i.e. wet and dry, herein referred to as ww and dw, respectively).  Boxplots provide an order of magnitude of the mean value and of the spread of the biomass data for each size fraction and biomass category.  The boxplots also include potential outliers which are identified as biomass values falling outside the broadened inter-quartile range (*i.e.* values outside the range [$Q1-1.5*IQR$, $Q3+1.5*IQR$]).  This test also looks at the frequency distribution of the biomass data for each size fraction and biomass category over different intervals of biomass values based on the range of the data shown in the boxplots.

_Test result:_
<br>

```{r boxplots, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE, fig.cap="Boxplots of biomass data for each size fraction and biomass category. Black and red dots represent observations and potential outliers, respectively."}
# check data - extreme values for small/large/total for dry and wet biomass
# prepare data
df_extremes <- dplyr::left_join(df_biomass_grouped_l %>%
																	dplyr::filter(., !is.na(value)) %>%
																	dplyr::filter(., !is.infinite(value)) %>%
																	dplyr::select(., sample_id, variable, value) %>%
																	tidyr::separate(., variable, c("label1", "label2"), sep="_", remove=FALSE) %>%
																	dplyr::mutate(., label1=ifelse(label1=="dw2", "Dry biomass",
																																 ifelse(label1=="ww2", "Wet biomass", NA))) %>%
																	dplyr::mutate(., label2=ifelse(label2=="S", "Small",
																																 ifelse(label2=="L", "Large",
																																 			 ifelse(label2=="T", "Total", NA)))),
																df_biomass_grouped_l %>%
																	dplyr::filter(., !is.na(value)) %>%
																	dplyr::select(., sample_id, variable, value) %>%
																	dplyr::group_by(., variable) %>%
																	dplyr::summarise(., q1=quantile(value, 0.25, type=7), q3=quantile(value, 0.75, type=7), iqr=IQR(value)) %>%
																	dplyr::ungroup(.),
																by="variable") %>%
	dplyr::mutate(., label3=ifelse(value<(q1-1.5*iqr), "out",
																 ifelse(value>(q3+1.5*iqr), "out", "good"))) %>%
	dplyr::select(., sample_id, variable, value, label1, label2, label3)

# empty list to store plots
p <- list()
i <- 0

for(i_type in c("Dry biomass", "Wet biomass")){
	for(i_size in c("Small", "Large", "Total")){
		
		i <- i+1
		
		## initialize plot
		if(i %in% c(1,4)){
			p[[i]] <- ggplot() +
				coord_cartesian() +
				scale_x_discrete(name=i_size, breaks="", expand=c(0,0)) +
				scale_y_continuous(name="Biomass [g/m2]", expand=c(0.05,0.05))
		} else {
			p[[i]] <- ggplot() +
				coord_cartesian() +
				scale_x_discrete(name=i_size, breaks="", expand=c(0,0)) +
				scale_y_continuous(name="", expand=c(0.05,0.1))
		}
		
		## plot data - good points
		p[[i]] <- p[[i]] +
			layer(
				data=df_extremes %>%
					dplyr::filter(., label1==i_type, label2==i_size, label3=="good"),
				mapping=aes(x=variable, y=value),
				stat="identity",
				geom="point",
				params=list(shape=20, colour="black", size=2),
				position=position_jitter(width=0.2, height=0)
			)
		
		## boxplot
		p[[i]] <- p[[i]] + 
			layer(
				data=df_extremes %>%
					dplyr::filter(., label1==i_type, label2==i_size),
				mapping=aes(x=variable, y=value),
				stat="boxplot",
				geom="boxplot",
				params=list(outlier.shape = NA, color="green", fill="green", alpha=0.25, width=0.4),
				position=position_identity()
			)
		
		## plot data - outliers
		p[[i]] <- p[[i]] +
			layer(
				data=df_extremes %>%
					dplyr::filter(., label1==i_type, label2==i_size, label3=="out"),
				mapping=aes(x=variable, y=value),
				stat="identity",
				geom="point",
				params=list(shape=20, colour="red", size=2),
				position=position_jitter(width=0.2, height=0)
			)
		
		## customize plot components
		p[[i]] <- p[[i]] +
			theme_bw() +
			ggtitle(i_type) +
			theme(
				text=element_text(size=10),
				plot.title=element_text(colour="black", angle=0, hjust=0.5, vjust=0, size=10),
				axis.text.x=element_text(colour="black", angle=0, hjust=0.5, vjust=0.5, size=10),
				axis.text.y=element_text(colour="black", angle=0, hjust=0.5, vjust=0.5, size=10),
				panel.border=element_rect(size=0.25, colour="black"),
				plot.margin=unit(c(0.1,0.1,0.1,0.1), "cm")
			)
	}
}

# arrange plots
grid.arrange(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], p[[6]], nrow=2, ncol=3)

rm(df_extremes)
```

Figure 1 shows a large number of biomass data points identified as potential outliers and suggests that the number of outliers might be considered excessive based on the IQR criterion alone.  Instead, the frequency distribution of the biomass data for each size fraction and biomass category over different intervals of biomass as presented in Tables 7 to 12 appears to be a better tool in order to narrow down the number of potential outliers.

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# data distribution
df_dw2_S <- summary(cut(df_biomass_grouped_l %>% filter(., variable=="dw2_S" & !is.na(value) & !is.infinite(value)) %>% .$value,
												breaks=c(0,50,100,150,200,250,300,350),
												labels=c("0-50","50-100","100-150","150-200","200-250","250-300","300-350")))
# fix names
df_dw2_S <- data.frame("Biomass range"=names(df_dw2_S), "Number obs"=df_dw2_S, row.names=NULL)
names(df_dw2_S) <- gsub(x = names(df_dw2_S), pattern = "\\.", replacement = " ")

# transpose
t_df_dw2_S <- transpose(df_dw2_S)

# fix names
colnames(t_df_dw2_S) <- rownames(df_dw2_S)
rownames(t_df_dw2_S) <- colnames(df_dw2_S)

knitr::kable(t_df_dw2_S, col.names=NULL, caption="Frequency distribution of small dry biomass data.",format="latex", booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"), position="left")
rm(t_df_dw2_S)
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# data distribution
df_dw2_L <- summary(cut(df_biomass_grouped_l %>% filter(., variable=="dw2_L" & !is.na(value) & !is.infinite(value)) %>% .$value,
												breaks=c(0,2.5,5,7.5,10,12.5,15),
												labels=c("0-2.5","2.5-5","5-7.5","7.5-10","10-12.5","12.5-15")))
# fix names
df_dw2_L <- data.frame("Biomass range"=names(df_dw2_L), "Number obs"=df_dw2_L, row.names=NULL)
names(df_dw2_L) <- gsub(x = names(df_dw2_L), pattern = "\\.", replacement = " ")

# transpose
t_df_dw2_L <- transpose(df_dw2_L)

# fix names
colnames(t_df_dw2_L) <- rownames(df_dw2_L)
rownames(t_df_dw2_L) <- colnames(df_dw2_L)

knitr::kable(t_df_dw2_L, col.names=NULL, caption="Frequency distributionof large dry biomass data.",format="latex", booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"), position="left")
rm(t_df_dw2_L)
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# data distribution
df_dw2_T <- summary(cut(df_biomass_grouped_l %>% filter(., variable=="dw2_T" & !is.na(value) & !is.infinite(value)) %>% .$value,
												breaks=c(0,500,1000,5000,10000),
												labels=c("0-500","500-1000","1000-5000","5000-10000")))
# fix names
df_dw2_T <- data.frame("Biomass range"=names(df_dw2_T), "Number obs"=df_dw2_T, row.names=NULL)
names(df_dw2_T) <- gsub(x = names(df_dw2_T), pattern = "\\.", replacement = " ")

# transpose
t_df_dw2_T <- transpose(df_dw2_T)

# fix names
colnames(t_df_dw2_T) <- rownames(df_dw2_T)
rownames(t_df_dw2_T) <- colnames(df_dw2_T)

knitr::kable(t_df_dw2_T, col.names=NULL, caption="Frequency distribution of total dry biomass data.",format="latex", booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"), position="left")
rm(t_df_dw2_T)
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# data distribution
df_ww2_S <- summary(cut(df_biomass_grouped_l %>% filter(., variable=="ww2_S" & !is.na(value) & !is.infinite(value)) %>% .$value,
												breaks=c(0,50,100,150,200,250,300,350,750),
												labels=c("0-50","50-100","100-150","150-200","200-250","250-300","300-350","350-750")))
# fix names
df_ww2_S <- data.frame("Biomass range"=names(df_ww2_S), "Number obs"=df_ww2_S, row.names=NULL)
names(df_ww2_S) <- gsub(x = names(df_ww2_S), pattern = "\\.", replacement = " ")

# transpose
t_df_ww2_S <- transpose(df_ww2_S)

# fix names
colnames(t_df_ww2_S) <- rownames(df_ww2_S)
rownames(t_df_ww2_S) <- colnames(df_ww2_S)

knitr::kable(t_df_ww2_S, col.names=NULL, caption="Frequency distribution of small wet biomass data.",format="latex", booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"), position="left")
rm(t_df_ww2_S)
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# data distribution
df_ww2_L <- summary(cut(df_biomass_grouped_l %>% filter(., variable=="ww2_L" & !is.na(value) & !is.infinite(value)) %>% .$value,
												breaks=c(0,50,100,150,200,250,300,350,500,1500),
												labels=c("0-50","50-100","100-150","150-200","200-250","250-300","300-350","350-500","500-1500")))
# fix names
df_ww2_L <- data.frame("Biomass range"=names(df_ww2_L), "Number obs"=df_ww2_L, row.names=NULL)
names(df_ww2_L) <- gsub(x = names(df_ww2_L), pattern = "\\.", replacement = " ")

# transpose
t_df_ww2_L <- transpose(df_ww2_L)

# fix names
colnames(t_df_ww2_L) <- rownames(df_ww2_L)
rownames(t_df_ww2_L) <- colnames(df_ww2_L)

knitr::kable(t_df_ww2_L, col.names=NULL, caption="Frequency distribution of large wet biomass data.",format="latex", booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"), position="left")
rm(t_df_ww2_L)
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
# data distribution
df_ww2_T <- summary(cut(df_biomass_grouped_l %>% filter(., variable=="ww2_T" & !is.na(value) & !is.infinite(value)) %>% .$value,
												breaks=c(0,50,100,150,200,250,300,350,500,1500),
												labels=c("0-50","50-100","100-150","150-200","200-250","250-300","300-350","350-500","500-1500")))
# fix names
df_ww2_T <- data.frame("Biomass range"=names(df_ww2_T), "Number obs"=df_ww2_T, row.names=NULL)
names(df_ww2_T) <- gsub(x = names(df_ww2_T), pattern = "\\.", replacement = " ")

# transpose
t_df_ww2_T <- transpose(df_ww2_T)

# fix names
colnames(t_df_ww2_T) <- rownames(df_ww2_T)
rownames(t_df_ww2_T) <- colnames(df_ww2_T)

knitr::kable(t_df_ww2_T, col.names=NULL, caption="Frequency distribution of total wet biomass data.",format="latex", booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"), position="left")
rm(t_df_ww2_T)
```

&nbsp;
&nbsp;

Based on the biomass data frequency distributions presented in Tables 7 to 12, biomass threshold values for each size fraction and biomass category were established as summarized in Table 13.  Table 14 presents a summary of samples for which biomass values are above the thresholds contained in Table 13, which can then be considered as potential outliers.

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
knitr::kable(data.frame(Small=c(100,200), Large=c(7.5, 250), Total=c(500, 250), row.names= c("Dry", "Wet")), caption="Biomass thresholds identified from frequency distribution tables for each size fraction and biomass type.", format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA}
options(knitr.kable.NA = "")
# data distribution
df_obs <- dplyr::bind_rows(df_biomass_grouped_l %>%
													 	dplyr::filter(., variable=="dw2_S" & value>=100) %>%
													 	dplyr::mutate(., label="dw_S") %>%
													 	dplyr::select(., sample_id, label, value),
													 df_biomass_grouped_l %>%
													 	dplyr::filter(., variable=="dw2_L" & value>=7.5) %>%
													 	dplyr::mutate(., label="dw_L") %>%
													 	dplyr::select(., sample_id, label, value),
													 df_biomass_grouped_l %>%
													 	dplyr::filter(., variable=="dw2_T" & value>=500) %>%
													 	dplyr::mutate(., label="dw_T") %>%
													 	dplyr::select(., sample_id, label, value),
													 df_biomass_grouped_l %>%
													 	dplyr::filter(., variable=="ww2_S" & value>=200) %>%
													 	dplyr::mutate(., label="ww_S") %>%
													 	dplyr::select(., sample_id, label, value),
													 df_biomass_grouped_l %>%
													 	dplyr::filter(., variable=="ww2_L" & value>=250) %>%
													 	dplyr::mutate(., label="ww_L") %>%
													 	dplyr::select(., sample_id, label, value),
													 df_biomass_grouped_l %>%
													 	dplyr::filter(., variable=="ww2_T" & value>=250) %>%
													 	dplyr::mutate(., label="ww_T") %>%
													 	dplyr::select(., sample_id, label, value)) %>%
	tidyr::spread(., label, value)

if(nrow(df_obs)==0){
	cat("There were no samples identified which appear to be outliers.")
} else {
	knitr::kable(dplyr::left_join(df_obs,
																df_sample %>%
																	dplyr::select(., sample_id, mission_descriptor, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw_S, dw_L, dw_T, ww_S, ww_L, ww_T) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::arrange(., dw_S, dw_L, dw_T, ww_S, ww_L, ww_T),
							 caption="Potential outliers identified from boxplots and frequency distribution of biomass data",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_obs)
```

_Action:_ Re-assessment of raw sample weights required for samples in Table 14 which are identified as potential outliers (*i.e.* value appears too large compared to the bulk of the observed biomass).

## Sum of Small and Large biomass vs. Total biomass
_Test description:_
This test checks for samples where the sum of the small and large biomass is not within 10% of the measured total biomass.

### Dry biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
# check data - small + large =? total
df_sum_dw <- df_biomass_grouped_w %>%
	dplyr::mutate(., dw2_sum=dw2_S + dw2_L) %>%
	dplyr::filter(., !is.na(dw2_sum) & !is.na(dw2_T) & !(dw2_sum>=0.9*dw2_T & dw2_sum<=1.1*dw2_T))

if(nrow(df_sum_dw)==0){
	cat("There were no samples identified where the sum of small and large dry biomass is not equal\n to the total dry biomass.")
} else {
	knitr::kable(dplyr::left_join(df_sum_dw %>%
																	dplyr::select(., sample_id, dw2_S, dw2_L, dw2_sum, dw2_T),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw2_S, dw2_L, dw2_sum, dw2_T) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Small=dw2_S, Large=dw2_L, `S+L`=dw2_sum, Total=dw2_T),
							 caption="Samples where the sum of the small and large dry biomass does not equal the total dry biomass.",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_sum_dw)
```

### Wet biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
# check data - small + large =? total
df_sum_ww <- df_biomass_grouped_w %>%
	dplyr::mutate(., ww2_sum=ww2_S + ww2_L) %>%
	dplyr::filter(., !is.na(ww2_sum) & !is.na(ww2_T) & !(ww2_sum>=0.9*ww2_T & ww2_sum<=1.1*ww2_T))

if(nrow(df_sum_ww)==0){
	cat("There were no samples identified where the sum of small and large wet biomass is not equal\n to the total wet biomass.")
} else {
	knitr::kable(dplyr::left_join(df_sum_ww %>%
																	dplyr::select(., sample_id, ww2_S, ww2_L, ww2_sum, ww2_T),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, ww2_S, ww2_L, ww2_sum, ww2_T) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Small=ww2_S, Large=ww2_L, `S+L`=ww2_sum, Total=ww2_T),
							 caption="Samples where the sum of the small and large wet biomass does not equal the total wet biomass.",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_sum_ww)
```

_Action:_ Re-assessment of raw sample weights required for samples in Table 15 where the small and large wet biomass do not add up to the total wet biomass value.

## Dry vs wet biomass for Small, Large and Total
_Test description:_
This test checks for samples where the dry biomass is larger than the wet biomass for a given size fraction.

### Small biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
# check data - dry small <? wet small
df_small <- df_biomass_grouped_w %>%
	dplyr::filter(., dw2_S > ww2_S | dw2_S > ww2_T)

if(nrow(df_small)==0){
	cat("There were no samples identified where the small dry biomass is larger than the corresponding\n small wet biomass or the total wet biomass.")
} else {
	knitr::kable(dplyr::left_join(df_small %>%
																	dplyr::select(., sample_id, dw2_S, ww2_S, ww2_T),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw2_S, ww2_S, ww2_T) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Dry_small=dw2_S, Wet_small=ww2_S, Wet_total=ww2_T),
							 caption="Samples with dry small biomass inconsistent with small or total wet biomass.",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_small)
```

### Large biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
# check data - dry <? wet
df_large <- df_biomass_grouped_w %>%
	dplyr::filter(., dw2_L > ww2_L)

if(nrow(df_large)==0){
	cat("There were no samples identified where the large dry biomass is larger than the corresponding\n large wet biomass.")
} else {
	knitr::kable(dplyr::left_join(df_large %>%
																	dplyr::select(., sample_id, dw2_L, ww2_L),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw2_L, ww2_L) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Dry=dw2_L, Wet=ww2_L),
							 caption="Samples with dry > wet large biomass.",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_large)
```

### Total biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
# check data - dry <? wet
df_total <- df_biomass_grouped_w %>%
	dplyr::filter(., dw2_T > ww2_T)

if(nrow(df_total)==0){
	cat("There were no samples identified where the total dry biomass is larger than the corresponding\n total wet biomass.")
} else {
	knitr::kable(dplyr::left_join(df_total %>%
																	dplyr::select(., sample_id, dw2_T, ww2_T),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw2_T, ww2_T) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Dry=dw2_T, Wet=ww2_T),
							 caption="Samples with dry > wet total biomass.",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_total)
```

_Action:_ Re-assessment of raw sample weights required for samples in Table 16 where the small dry biomass is either larger than the corresponding small wet biomass or the total wet biomass.

## Dry vs wet biomass regression outliers
_Test description:_
This test looks at the relationship between the dry biomass and the wet biomass for a given size fraction in order to identify potential outliers (*i.e.* data points that depart from the expected relationship between the dry and wet biomass).  Two statistics are used to identify potential outliers: 1) Cook's distance and, 2) standardized residuals.  Potential outliers are identified, respectively, as points where Cook's distance is larger than the mean distance and where the standardized residual absolute value is larger than 2.

### Small biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE, fig.cap="Relationship between dry and wet biomass for the small size fraction with potential outliers identified using the Cook's distance threshold (left panel) and the standardized residuals threshold (right panel). Black and red dots represent observations and potential outliers, respectively.", out.extra=""}
df_reg_small <- df_biomass_grouped_w %>%
	dplyr::select(., sample_id, dw2_S, ww2_S) %>%
	dplyr::filter(., !(is.na(dw2_S) | is.na(ww2_S)))

if(nrow(df_reg_small)<10){
	cat("There were not enough samples to calculate regression fit between dry and wet small biomass.")
} else {
	# fit linear model
	lm_fit <- lm(data=df_reg_small, formula=dw2_S ~ 0 + ww2_S)
	
	# extract coefficients
	lm_coeff = summary(lm_fit)
	
	# add Cook's distance and stardardized residuals to data frame
	df_reg_small <- dplyr::bind_cols(df_reg_small, data.frame(cooks=cooks.distance(lm_fit),
																														rstd=rstandard(lm_fit))) %>%
		dplyr::mutate(., cooks_lbl=ifelse(cooks>mean(cooks), "out", "good")) %>%
		dplyr::mutate(., rstd_lbl=ifelse(abs(rstd)>2, "out", "good"))
	
	p <- list()
	
	# Cook's distance
	p[[1]] <- ggplot() +
		coord_cartesian() +
		scale_x_continuous(name="Wet biomass", expand=c(0.05,0.05)) +
		scale_y_continuous(name="Dry biomass", expand=c(0.05,0.05))
	
	## plot data - good points
	p[[1]] <- p[[1]] +
		layer(
			data=df_reg_small %>%
				dplyr::filter(., cooks_lbl=="good"),
			mapping=aes(x=ww2_S, y=dw2_S),
			stat="identity",
			geom="point",
			params=list(shape=20, colour="black", size=2),
			position=position_identity()
		)
	
	## plot regression
	p[[1]] <- p[[1]] + 
		layer(
			data=df_reg_small,
			mapping=aes(x=ww2_S, y=dw2_S),
			stat="smooth",
			geom="smooth",
			params=list(method="lm", formula="y ~ 0 + x", size=.75, colour="green"),
			position=position_identity()
		)
	
	## plot data - outliers
	p[[1]] <- p[[1]] +
		layer(
			data=df_reg_small %>%
				dplyr::filter(., cooks_lbl=="out"),
			mapping=aes(x=ww2_S, y=dw2_S),
			stat="identity",
			geom="point",
			params=list(shape=20, colour="red", size=2),
			position=position_identity()
		)
	
	# add text
	label <- paste("dw =", signif(lm_coeff$coef[1], 3),"* ww",
								 " \nr2 =", signif(lm_coeff$r.squared, 2))
	p[[1]] <- p[[1]] + annotate(geom="text", x=400, y=150, label=label, size=3, hjust=0.5, colour="green", size=12)
	
	## customize plot components
	p[[1]] <- p[[1]] +
		theme_bw() +
		ggtitle("Small biomass\nCook's distance threshold") +
		theme(
			text=element_text(size=10),
			plot.title=element_text(colour="black", angle=0, hjust=0, vjust=0, size=10),
			axis.text.x=element_text(colour="black", angle=0, hjust=0.5, vjust=0.5, size=10),
			axis.text.y=element_text(colour="black", angle=0, hjust=0.5, vjust=0.5, size=10),
			panel.border=element_rect(size=0.25, colour="black"),
			plot.margin=unit(c(0.1,0.1,0.1,0.1), "cm")
		)
	
	# standardized residuals
	p[[2]] <- ggplot() +
		coord_cartesian() +
		scale_x_continuous(name="Wet biomass", expand=c(0.05,0.05)) +
		scale_y_continuous(name="", expand=c(0.05,0.05))
	
	## plot data - good points
	p[[2]] <- p[[2]] +
		layer(
			data=df_reg_small %>%
				dplyr::filter(., rstd_lbl=="good"),
			mapping=aes(x=ww2_S, y=dw2_S),
			stat="identity",
			geom="point",
			params=list(shape=20, colour="black", size=2),
			position=position_identity()
		)
	
	## plot regression
	p[[2]] <- p[[2]] + 
		layer(
			data=df_reg_small,
			mapping=aes(x=ww2_S, y=dw2_S),
			stat="smooth",
			geom="smooth",
			params=list(method="lm", formula="y ~ 0 + x", size=.75, colour="green"),
			position=position_identity()
		)
	
	## plot data - outliers
	p[[2]] <- p[[2]] +
		layer(
			data=df_reg_small %>%
				dplyr::filter(., rstd_lbl=="out"),
			mapping=aes(x=ww2_S, y=dw2_S),
			stat="identity",
			geom="point",
			params=list(shape=20, colour="red", size=2),
			position=position_identity()
		)
	
	# add text
	label <- paste("dw =", signif(lm_coeff$coef[1], 3),"* ww",
								 " \nr2 =", signif(lm_coeff$r.squared, 2))
	p[[2]] <- p[[2]] + annotate(geom="text", x=400, y=150, label=label, size=3, hjust=0.5, colour="green", size=12)
	
	## customize plot components
	p[[2]] <- p[[2]] +
		theme_bw() +
		ggtitle("Small biomass\nStandardized residuals threshold") +
		theme(
			text=element_text(size=10),
			plot.title=element_text(colour="black", angle=0, hjust=0, vjust=0, size=10),
			axis.text.x=element_text(colour="black", angle=0, hjust=0.5, vjust=0.5, size=10),
			axis.text.y=element_text(colour="black", angle=0, hjust=0.5, vjust=0.5, size=10),
			panel.border=element_rect(size=0.25, colour="black"),
			plot.margin=unit(c(0.1,0.1,0.1,0.1), "cm")
		)
	
	# arrange plots
	grid.arrange(p[[1]], p[[2]], nrow=1, ncol=2)
}
```	

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
if(nrow(df_reg_small)>0){
	# output to table - Cook's and rstd outliers
	knitr::kable(dplyr::left_join(df_reg_small %>%
																	dplyr::filter(., cooks_lbl=="out" & rstd_lbl=="out") %>%
																	dplyr::select(., sample_id, dw2_S, ww2_S),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw2_S, ww2_S) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Dry=dw2_S, Wet=ww2_S),
							 caption="Samples identified as outliers using both Cook's distance threshold and standardized residuals threshold.",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
	
}
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
if(nrow(df_reg_small)>0){
	# output to table - additional Cook's distance outliers
	knitr::kable(dplyr::left_join(df_reg_small %>%
																	dplyr::filter(., cooks_lbl=="out" & rstd_lbl=="good") %>%
																	dplyr::select(., sample_id, dw2_S, ww2_S),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw2_S, ww2_S) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Dry=dw2_S, Wet=ww2_S),
							 caption="Additional samples identified as outliers using Cook's distance threshold.",
							 digits=2,format="latex", longtable=T, booktabs=T)
}
```

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
if(nrow(df_reg_small)>0){
	# output to table - additional Cook's distance outliers
	knitr::kable(dplyr::left_join(df_reg_small %>%
																	dplyr::filter(., cooks_lbl=="good" & rstd_lbl=="out") %>%
																	dplyr::select(., sample_id, dw2_S, ww2_S),
																df_sample %>%
																	dplyr::select(., mission_descriptor, sample_id, collector_sample_id),
																by="sample_id") %>%
							 	dplyr::select(., mission_descriptor, collector_sample_id, dw2_S, ww2_S) %>%
							 	dplyr::distinct(.) %>%
							 	dplyr::rename(., Dry=dw2_S, Wet=ww2_S),
							 caption="Additional samples identified as outliers using standardized residuals threshold.",
							 digits=2,format="latex", longtable=T, booktabs=T) %>%
		kable_styling(latex_options = c("striped", "HOLD_position", "repeat_header"))
}
rm(df_reg_small)
```

### Large biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
df_reg_large <- df_biomass_grouped_w %>%
	dplyr::select(., sample_id, dw2_L, ww2_L) %>%
	dplyr::filter(., !(is.na(dw2_L) | is.na(ww2_L)))

if(nrow(df_reg_large)<10){
	cat("There were not enough samples to calculate a regression fit between dry and wet large biomass.")
}
```

### Total biomass
_Test result:_
<br>

```{r, echo=FALSE, eval=TRUE, include=TRUE, comment=NA, warning=FALSE}
df_reg_total <- df_biomass_grouped_w %>%
	dplyr::select(., sample_id, dw2_T, ww2_T) %>%
	dplyr::filter(., !(is.na(dw2_T) | is.na(ww2_T)))

if(nrow(df_reg_large)<10){
	cat("There were not enough samples to calculate a regression fit between dry and wet total biomass.")
}
```

_Action:_ Re-assessment of raw sample weights required for samples in Table 17, 18 and 18 which indicate excessive departure from the relationship between the small dry biomass and the small wet biomass.

<!-------------------------------------------------------------------------------------------->
# Comments
This report has identified a relatively large number of samples archived in BioChem for which the plankton weight data do require further attention.  The samples identified from the various tests described in section 3 (sample metadata checks) and section 4 (sample weight data check) can be addressed and corrected in a straightforward manner by checking the validity of the data that appear incoherent.  Some of these might be the result of errors in the source data files (*e.g.* typos) that are propagated to BioChem upon loading of the source files.  Following proper verifications, samples for which some parameters still reveal incoherent (*e.g.* zero volume) should likely be removed from BioChem.

Some of the samples identified from the various tests described in sections 5 (biomass data checks) can also be addressed and corrected in a straightforward manner by checking the validity of the data that appear incoherent.  These include the cases where the small and large biomass do not add up to the total biomass (Table 15), cases where the dry biomass is larger than the wet biomass for a given size fraction (Table 16), and cases where the data is clearly reported with wrong units of measurement (*e.g.* total dry biomass from Table 14).

Other samples from the biomass data checks that have been identified as potential outliers, either from the boxplots and/or the data frequency distribution (Table 14) or from the regression between the dry and wet biomass (Tables 17, 18 and 19) do require special attention.  In some cases, a re-analysis of the sample weight might be advisable.  Following proper verifications, samples for which large biomass values are deemed acceptable (*e.g.* due to the dominant presence of phytoplankton, or the presence of large zooplankton individuals) should be tagged accordingly and in a standard manner.  Ultimately, a quality control code should be associated with each plankton weight data found in BioChem's BCPLANKTNGENERALS table.
